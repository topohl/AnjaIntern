md2 <- select(md2,c(DateTime, PositionID))
plot_micePositions_together(md1, md2)
ggplot() +
geom_point(data = data, aes(x = time, y = y_value), size = 3, color = "blue") +
geom_segment(data = data %>% mutate(next_time = lead(time, default = last(time))),
aes(x = time, xend = next_time, y = y_value, yend = y_value),
arrow = arrow(length = unit(0.2, "cm")), size = 1, color = "blue") +
geom_point(data = data2, aes(x = time, y = y_value), size = 3, color = "red") +
geom_segment(data = data2 %>% mutate(next_time = lead(time, default = last(time))),
aes(x = time, xend = next_time, y = y_value, yend = y_value),
arrow = arrow(length = unit(0.2, "cm")), size = 1, color = "red") +
geom_point(data = data3, aes(x = time, y = y_value), size = 3, color = "yellow") +
geom_segment(data = data3 %>% mutate(next_time = lead(time, default = last(time))),
aes(x = time, xend = next_time, y = y_value, yend = y_value),
arrow = arrow(length = unit(0.2, "cm")), size = 1, color = "yellow") +
geom_point(data = data4, aes(x = time, y = y_value), size = 3, color = "green") +
geom_segment(data = data4 %>% mutate(next_time = lead(time, default = last(time))),
aes(x = time, xend = next_time, y = y_value, yend = y_value),
arrow = arrow(length = unit(0.2, "cm")), size = 1, color = "green") +
geom_hline(yintercept = 1:8, color = "black", linetype = "solid", size = 0.5) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +  # X-Achsenbeschriftung
scale_y_continuous(breaks = seq(1.0,9.0, by=0.5), labels = custom_labels) +  # Y-Achsenbeschriftung
labs(x = "Zeitspanne (24h)", y = "Felder (1-8)",
title = "Vier Reihen von Punkten mit waagerechten Linien",
color = "Datenreihe") +
theme_minimal()
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
## 11/2023
## Anja Magister
## ANALYSIS OF ANIMAL POSITIONS - VERSION2 ##
##
# libraries
library(readr)        # load readr package for reading csv files
library(stringr)
library(dplyr)
library(lubridate)    # for rounding time, time operations in general
library(tibble)       #important for tibble operations
library(purrr)
# paths
fileSourcePath <-  "S:/Lab_Member/Anja/Git/AnjaIntern/E9_SIS_B3_CC1_AnimalPos.csv"
#fuctions
working_directory <- "S:/Lab_Member/Anja/Git/AnjaIntern"
source(paste0(working_directory,"/E9_SIS_B3_CC1_AnimalPos-functions.R"))
# read csv file in tibble
overallData <- read_delim(fileSourcePath,delim = ";", show_col_types = FALSE)
####################################################################################################################################
######ORGANIZATION OF overallData:######
# delete unnecessary columns
overallData <- select(overallData, -c(RFID, AM, zPos))
# convert the DateTime column to a datetime format(also rounds the DateTime)
overallData$DateTime <- as.POSIXct(overallData$DateTime, format = "%d.%m.%Y %H:%M:%S")
# separate Animal into his ID an his system
overallData[c('AnimalID', 'System')] <- str_split_fixed(overallData$Animal, '_', 2)
###### convert xPos and yPos into one column named "PositionID" ######
#create Positions_tibble that contains every possible combination of our coordinates together with an ID
positions <- select(overallData, c(xPos,yPos))
unique_positions <- unique(positions)
Positions_tibble <- tibble(PositionID = c(1:length(unique_positions$xPos)), xPos = unique_positions[1], yPos = unique_positions[2])
# Adding column PositionID to overallData instead of two colums with x and y coordinates
overallData_ids <- overallData %>% rowwise() %>%
mutate(PositionID = find_id(xPos, yPos, Positions_tibble))
##### sort columns #####
overallData_final <- overallData_ids[c('DateTime', 'AnimalID', 'System', 'PositionID')]
# column as tibble
overallData_final <- as_tibble(overallData_final)
################################################################################################################################
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
mouse_names_systemOne <- unique(mice_systemOne$AnimalID)
#####################################################################################
#update mice_list to first time and first position
mice_list <- find_first_pos_and_time(mouse_names_systemOne, overallData_final, mice_list)
#####################################################################################
#initialize mice closeness result
count_closeness_list <- list(   m1=c(0,0,0,0),
m2=c(0,0,0,0),
m3=c(0,0,0,0),
m4=c(0,0,0,0))
#update closeness list
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
#################################################################################
##assign start time(choose one of the mices start time)
start_time <- mice_list[[1]][[2]]
time <- start_time
###try a loop
#first last second:
#last_time <- "2023-04-28 11:00:14"
last_time <- "2023-04-25 11:00:14"
for(i in 1:3600){
time <- sec_shift(time)
mice_list <- update_mice_list(mouse_names_systemOne, mice_list, overallData_final, time)
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
}
## 11/2023
## Anja Magister
## ANALYSIS OF ANIMAL POSITIONS - VERSION2 ##
##
# libraries
library(readr)        # load readr package for reading csv files
library(stringr)
library(dplyr)
library(lubridate)    # for rounding time, time operations in general
library(tibble)       #important for tibble operations
library(purrr)
# paths
fileSourcePath <-  "S:/Lab_Member/Anja/Git/AnjaIntern/E9_SIS_B3_CC1_AnimalPos.csv"
#fuctions
working_directory <- "S:/Lab_Member/Anja/Git/AnjaIntern"
source(paste0(working_directory,"/E9_SIS_B3_CC1_AnimalPos-functions.R"))
# read csv file in tibble
overallData <- read_delim(fileSourcePath,delim = ";", show_col_types = FALSE)
####################################################################################################################################
######ORGANIZATION OF overallData:######
# delete unnecessary columns
overallData <- select(overallData, -c(RFID, AM, zPos))
# convert the DateTime column to a datetime format(also rounds the DateTime)
overallData$DateTime <- as.POSIXct(overallData$DateTime, format = "%d.%m.%Y %H:%M:%S")
# separate Animal into his ID an his system
overallData[c('AnimalID', 'System')] <- str_split_fixed(overallData$Animal, '_', 2)
###### convert xPos and yPos into one column named "PositionID" ######
#create Positions_tibble that contains every possible combination of our coordinates together with an ID
positions <- select(overallData, c(xPos,yPos))
unique_positions <- unique(positions)
Positions_tibble <- tibble(PositionID = c(1:length(unique_positions$xPos)), xPos = unique_positions[1], yPos = unique_positions[2])
# Adding column PositionID to overallData instead of two colums with x and y coordinates
overallData_ids <- overallData %>% rowwise() %>%
mutate(PositionID = find_id(xPos, yPos, Positions_tibble))
##### sort columns #####
overallData_final <- overallData_ids[c('DateTime', 'AnimalID', 'System', 'PositionID')]
# column as tibble
overallData_final <- as_tibble(overallData_final)
################################################################################################################################
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
mouse_names_systemOne <- unique(mice_systemOne$AnimalID)
#####################################################################################
#update mice_list to first time and first position
mice_list <- find_first_pos_and_time(mouse_names_systemOne, overallData_final, mice_list)
#####################################################################################
#initialize mice closeness result
count_closeness_list <- list(   m1=c(0,0,0,0),
m2=c(0,0,0,0),
m3=c(0,0,0,0),
m4=c(0,0,0,0))
#update closeness list
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
#################################################################################
##assign start time(choose one of the mices start time)
start_time <- mice_list[[1]][[2]]
time <- start_time
###try a loop
#first last second:
#last_time <- "2023-04-28 11:00:14"
last_time <- "2023-04-25 11:00:14"
for(i in 1:3600){
time <- sec_shift(time)
mice_list <- update_mice_list(mouse_names_systemOne, mice_list, overallData_final, time)
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
}
##############################################################################################################
# update mice_list(if its possible) and return it
# similarity to find_first_pos_and_time
update_mice_list <- function(system_mouse_names, mice_list, overallData_final, time){
#filter overallData_final with new_time
new_time_rows <- overallData_final%>%
filter(DateTime == as.POSIXct(as.numeric(time), origin = "1970-01-01"))
#print(new_time_rows)
# enter new data in mice_list
for (i in 1:length(system_mouse_names)){ #i=1-4
#rename
mouse_name <- system_mouse_names[[i]]
#search current animal
mouse_entry <- new_time_rows%>%
filter(AnimalID == mouse_name)
#print(mouse_entry)
#if double position entrys for same second, take first entry
if(nrow(mouse_entry)>1){mouse_entry <- mouse_entry%>%slice(1)}
#if new position happened during this second
if(nrow(mouse_entry)==1){
print("new entrys")
#write name, position and time into mice_list
mice_list[i][[1]] <- mouse_name#redundant!
mice_list[[i]][[2]] <- time #mouse_entry$DateTime?
mice_list[[i]][[3]] <- mouse_entry$PositionID
}
}
return(mice_list)
}
##############################################################################################################
## plot ##
# Function for adjusting the Y-axis labelling
custom_labels <- function(x) {
labels <- ifelse(x %% 1 == 0, "", as.character(x - 0.5))  # show even numbers on odd place(number 1 on place 1.5), dont show even place numbers
return(labels)
}
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
mouse_names_systemOne <- unique(mice_systemOne$AnimalID)
#####################################################################################
#update mice_list to first time and first position
mice_list <- find_first_pos_and_time(mouse_names_systemOne, overallData_final, mice_list)
#####################################################################################
#initialize mice closeness result
count_closeness_list <- list(   m1=c(0,0,0,0),
m2=c(0,0,0,0),
m3=c(0,0,0,0),
m4=c(0,0,0,0))
#update closeness list
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
#################################################################################
##assign start time(choose one of the mices start time)
start_time <- mice_list[[1]][[2]]
time <- start_time
for(i in 1:6600){
time <- sec_shift(time)
mice_list <- update_mice_list(mouse_names_systemOne, mice_list, overallData_final, time)
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
}
check_closeness <- function(mice_list,count_closeness_list){
# compare the third value of every couple
# if the position is the same, save in count_closeness_list list
for (i in 1:3) {
for (j in (i+1):4) {
#print(c(i, j))
#print(mice_list[[i]][[3]]==mice_list[[j]][[3]])
if(mice_list[[i]][[3]]==mice_list[[j]][[3]]){
count_closeness_list[[i]][[j]] <- count_closeness_list[[i]][[j]]+1
}
}
}
#print(count_closeness_list)
# return updated list of mice that are close to each other
return(count_closeness_list)
}
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
mouse_names_systemOne <- unique(mice_systemOne$AnimalID)
#####################################################################################
#update mice_list to first time and first position
mice_list <- find_first_pos_and_time(mouse_names_systemOne, overallData_final, mice_list)
#####################################################################################
#initialize mice closeness result
count_closeness_list <- list(   m1=c(0,0,0,0),
m2=c(0,0,0,0),
m3=c(0,0,0,0),
m4=c(0,0,0,0))
#update closeness list
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
start_time <- mice_list[[1]][[2]]
time <- start_time
###try a loop
#first last second:
#last_time <- "2023-04-28 11:00:14"
last_time <- "2023-04-25 11:00:14"
for(i in 1:86400){
time <- sec_shift(time)
mice_list <- update_mice_list(mouse_names_systemOne, mice_list, overallData_final, time)
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
}
print(count_closeness_list)
# function to do shift in time(one second forward)
sec_shift <- function( old_time){
#put one second on top of old_time
new_time <- old_time%>%
as.numeric()%>%
+1%>%
as.character()
#cat("old time: ", old_time, "\n")
#cat("new time: ", new_time, "\n")
return(new_time)
}
# ALGORITHM:
# initialize mice lists with empty name, start time and start position of every mouse in one system(4mice together)
mouseOne    <- list(name="", time="", position=0)
mouseTwo    <- list(name="", time="", position=0)
mouseThree  <- list(name="", time="", position=0)
mouseFour   <- list(name="", time="", position=0)
#put the four lists in one list together
mice_list <- list(
"mouseOne" = mouseOne,
"mouseTwo" = mouseTwo,
"mouseThree" = mouseThree,
"mouseFour" = mouseFour)
#print the list of mice
for (sub_list in names(mice_list)) {
print(sub_list)
for (element in mice_list[[sub_list]]) {
print(element)
}
}
# save unique names of the first system:
mice_systemOne <- overallData_final%>%
filter(System == "sys.1")
mouse_names_systemOne <- unique(mice_systemOne$AnimalID)
#####################################################################################
#update mice_list to first time and first position
mice_list <- find_first_pos_and_time(mouse_names_systemOne, overallData_final, mice_list)
#####################################################################################
#initialize mice closeness result
count_closeness_list <- list(   m1=c(0,0,0,0),
m2=c(0,0,0,0),
m3=c(0,0,0,0),
m4=c(0,0,0,0))
#update closeness list
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
#################################################################################
##assign start time(choose one of the mices start time)
start_time <- mice_list[[1]][[2]]
time <- start_time
###try a loop
#first last second:
#last_time <- "2023-04-28 11:00:14"
last_time <- "2023-04-25 11:00:14"
for(i in 1:432000){
time <- sec_shift(time)
mice_list <- update_mice_list(mouse_names_systemOne, mice_list, overallData_final, time)
count_closeness_list <- check_closeness(mice_list, count_closeness_list)
}
print(count_closeness_list)
print(as.POSIXct(as.numeric(time), origin = "1970-01-01"))
time == "2023-04-29 12:24:52 CEST"
as.POSIXct(as.numeric(time), origin = "1970-01-01") == "2023-04-29 12:24:52 CEST"
######################################################################
# calculate second entrys to hour entrys
copy_list <- count_closeness_list
copy_list
ergebnis <- lapply(copy_list, function(x) x/60)
ergebnis
ergebnis <- lapply(copy_list, function(x) x/3600)
ergebnis
count_closeness_list_hours <- lapply(copy_list, function(x) x/3600)
# Konvertiere die Liste von Listen in eine Matrix
matrix_daten <- do.call(rbind, count_closeness_list_hours)
heatmap <- ggplot(data = as.data.frame(matrix_daten), aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
library(ggplot2)
# Erstelle die Heatmap mit ggplot2
heatmap <- ggplot(data = as.data.frame(matrix_daten), aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
# Zeige die Heatmap an
print(heatmap)
View(matrix_daten)
# Erstelle die Heatmap mit ggplot2
heatmap <- ggplot(data = as.data.frame(matrix_daten), aes(x = (V1:V4), y = (m1:m4), fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
# Zeige die Heatmap an
print(heatmap)
heatmap(matrix_daten,
Colv = NA,
Rowv = NA,
col = heat.colors(256),
scale = "column",
xlab = "X-Achse",
ylab = "Y-Achse",
main = "Heatmap der Daten")
# Konvertiere die Liste von Listen in eine Matrix
matrix_daten
matrix_data <- do.call(rbind, count_closeness_list_hours)
dimnames(matrix_data) <- list(c(m1,m2,m3,m4), c(m1,m2,m3,m4))
dimnames(matrix_data) <- list(c("m1","m2","m3","m4"), c("m1","m2","m3","m4"))
View(matrix_data)
# Erstelle die Heatmap mit ggplot2
heatmap <- ggplot(data = as.data.frame(matrix_data), aes(x = (V1:V4), y = (m1:m4), fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
# Zeige die Heatmap an
print(heatmap)
# Erstelle die Heatmap mit ggplot2
heatmap <- ggplot(data = as.data.frame(matrix_data), aes(x = Var2, y = Var1, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
# Zeige die Heatmap an
print(heatmap)
# Erstelle die Heatmap mit ggplot2
heatmap <- ggplot(data = as.data.frame(matrix_data), aes(x = m1:m4, y = m1:m4, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
# Zeige die Heatmap an
print(heatmap)
heatmap(matrix_data)
count_closeness_list_hours <- lapply(copy_list, ifelse(x!=0,function(x) x/3600,x))
count_closeness_list_hours <- lapply(copy_list, function(x) ifelse(x!=0,x/3600,x))
matrix_data <- do.call(rbind, count_closeness_list_hours)
dimnames(matrix_data) <- list(c("m1","m2","m3","m4"), c("m1","m2","m3","m4"))
heatmap(matrix_data, Rowv = NA, Colv = NA)
# heatmap plotly
install.packages("plotly")                                        # Install plotly package
library("plotly")
plot_ly(z = matrix_data, type = "heatmap")
install.packages("reshape")                                       # Install reshape package
library("reshape")
data_melt <- melt(matrix_data)                                           # Reorder data
head(data_melt)
data_melt
ggp <- ggplot(data_melt, aes(X1, X2)) +                           # Create heatmap with ggplot2
geom_tile(aes(fill = value))
ggp                                                               # Print heatmap
ggp <- ggplot(data_melt, aes(X1, X2)) +                           # Create heatmap with ggplot2
geom_tile(aes(fill = value))+
scale_fill_gradient(low = "white", high = "blue") +  # Farbgradient festlegen
labs(title = "Heatmap der Daten", x = "X-Achse", y = "Y-Achse")  # Beschriftungen hinzufügen
ggp                                                               # Print heatmap
